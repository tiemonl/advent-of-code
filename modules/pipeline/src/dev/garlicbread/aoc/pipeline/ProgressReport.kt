package dev.garlicbread.aoc.pipeline

import kotlinx.datetime.TimeZone
import kotlinx.datetime.number
import kotlinx.datetime.toLocalDateTime
import okio.FileSystem
import okio.Path.Companion.toPath
import okio.buffer
import org.w3c.dom.Element
import javax.xml.parsers.DocumentBuilderFactory
import kotlin.time.Clock
import kotlin.time.ExperimentalTime

private val YEAR_PROBLEMS = mapOf(
    2025 to 12,   // 2025 has 12 problems (24 parts)
)
private const val DEFAULT_DAYS_PER_YEAR = 25

private fun maxPartsForYear(year: Int): Int =
    (YEAR_PROBLEMS[year] ?: DEFAULT_DAYS_PER_YEAR) * 2

fun main() {
    val fs = FileSystem.SYSTEM

    val rootPath = ".".toPath()

    val reportFiles = fs.listRecursively(rootPath).filter { path ->
        path.segments.contains("build") &&
                path.segments.contains("reports") &&
                path.segments.contains("jvm") &&
                path.segments.any { it.matches("""20\d{2}""".toRegex()) } &&
                path.name == "TEST-junit-jupiter.xml"
    }.toList()

    if (reportFiles.isEmpty()) {
        println("No test report XML files found. Skipping README update.")
        return
    }

    val builder = DocumentBuilderFactory.newInstance().newDocumentBuilder()

    val testCases = mutableListOf<Case>()

    reportFiles.forEach { path ->
        try {
            fs.source(path).use { source ->
                val doc = builder.parse(source.buffer().readByteArray().inputStream())
                doc.documentElement.normalize()

                extractSuites(doc.documentElement).forEach {
                    val testCaseElement = it.getElementsByTagName("testcase")
                    for (i in 0 until testCaseElement.length) {
                        val testcase = testCaseElement.item(i)
                        if (testcase !is Element) continue
                        val parsedTestCase = parseTestCase(testcase) ?: continue
                        testCases.add(parsedTestCase)
                    }
                }
            }
        } catch (e: Exception) {
            println("Warning: couldn't parse XML file $path: ${e.message}")
        }
    }

    if (testCases.isEmpty()) {
        println("No testcases parsed. Skipping README update.")
        return
    }

    val solvedMap = buildMap {
        testCases.groupBy { it.year }.forEach { (year, tests) ->
            put(year, solvedWithMeta(tests))
        }
    }

    val updatedTable = createProgressTable(solvedMap)

    val readmePath = rootPath.resolve("README.md")
    if (!fs.exists(readmePath)) {
        println("README.md not found, skipping.")
        return
    }

    val original = fs.read(readmePath) { readUtf8() }
    val updated = updateTableInReadme(original, updatedTable)

    if (updated == original) {
        println("README.md already up to date.")
        return
    }

    fs.write(readmePath) {
        writeUtf8(updated)
    }

    println("README.md updated")
}

@OptIn(ExperimentalTime::class)
fun createProgressTable(solvedMap: Map<Int, Int>): String = buildString {
    appendLine("<!-- PROGRESS-START -->")
    appendLine("<!-- This section is auto-generated by CI. Do not edit manually. -->")
    appendLine()
    appendLine("### Overall Progress")

    val currentDateTime = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
    val latestAocYear = if (currentDateTime.month.number < 12) currentDateTime.year.dec() else currentDateTime.year
    val aocYears = (2015..latestAocYear)
    val totalSolved = solvedMap.values.sum()
    val totalPossible = aocYears.sumOf { maxPartsForYear(it) }
    val totalPct = if (totalPossible == 0) 0.0 else totalSolved.toDouble() / totalPossible * 100.0

    appendLine("- Total stars: **$totalSolved / $totalPossible** (${formatPercent(totalPct)})")
    appendLine()
    appendLine("### By Year")
    appendLine()
    appendLine("| Year | Stars | Progress |")
    appendLine("|------|-------|----------|")

    (aocYears).forEach { year ->
        val solved = solvedMap[year] ?: 0
        val possible = maxPartsForYear(year)
        val progressPercent = if (possible == 0) 0.0 else solved.toDouble() / possible * 100.0
        appendLine("| $year | $solved / $possible | `${progressBar(progressPercent)}` ${formatPercent(progressPercent)} |")
    }

    appendLine()
    append("<!-- PROGRESS-END -->")
}

fun updateTableInReadme(original: String, updatedTable: String): String {
    val start = "<!-- PROGRESS-START -->"
    val end = "<!-- PROGRESS-END -->"

    val startIndex = original.indexOf(start)
    val endIndex = original.indexOf(end)

    return if (startIndex != -1 && endIndex != -1) {
        val afterEnd = endIndex + end.length
        original.take(startIndex) + updatedTable + original.substring(afterEnd)
    } else {
        original.trimEnd() + "\n\n" + updatedTable
    }
}

private fun formatPercent(percent: Double) = String.format("%.1f%%", percent)

private fun progressBar(percent: Double): String {
    val barLen = 20
    val filled = (barLen * percent / 100).toInt().coerceIn(0, barLen)
    return "█".repeat(filled) + "░".repeat(barLen - filled)
}

private fun solvedWithMeta(testCases: List<Case>): Int {
    val raw = testCases.groupBy { it.toKey() }.values.count { it.all { it.pass } }
    val possible = maxPartsForYear(testCases.first().year)
    return if (raw == possible.dec()) possible else raw
}


private fun extractSuites(root: Element): List<Element> {
    if (root.tagName == "testsuite") return listOf(root)
    val list = root.getElementsByTagName("testsuite")
    return List(list.length) { list.item(it) as Element }
}

private fun parseTestCase(tc: Element): Case? {
    val classname = tc.getAttribute("classname") ?: ""
    val name = tc.getAttribute("name") ?: ""

    val year = Regex("""\.y(20\d{2})\.""")
        .find(classname)?.groupValues?.get(1)?.toIntOrNull() ?: return null

    val day = Regex("""Problem(\d+)""").find(classname) ?: return null

    val dayNum = day.groupValues[1].toInt()

    val part = Regex("""\$(Part[12])""").find(classname)?.groupValues?.last()?.last()?.digitToInt()
        ?: Regex("""(Part[12])""").find(name)?.groupValues?.last()?.last()?.digitToInt()
        ?: 0

    val pass = tc.getElementsByTagName("failure").length == 0

    return Case(year = year, day = dayNum, part = part, pass = pass)
}